#labels Featured
_
Эта страница рассказывает о функции `test`, добавляющей большего удобства и гибкости в пакетные файлы Windows. 
_

= Условные операторы на стероидах =

<wiki:toc max_depth="5" />


= ОПИСАНИЕ =

Этот скрипт расширяет условный оператор в пакетных файлах Windows. Как 
только в ваши скрипты он позволяет строить более мощные и гибкие условные 
операторы, реализованные на _стероидах_. 

Этот скрипт объявляет две _функции_, реализующие условные операторы для 
вычисления дополнительных условных выражений над файлами и строками. Эти 
функции завершаются с кодом возврата (0) или (1) в зависимости от 
вычисленного выражения. 

Выражения могут быть в стандартной форме оператора `IF`, используемого в 
пакетных сценариях. Детально синтаксис описан в справке команды `IF /?`. 

Вторая форма пришла из встроенной команды unix shell `test`, которая 
расширяет возможности стандартного оператора в пакетных файлах. Другими 
словами, это и есть *стероиды*. 


= ИСПОЛЬЗОВАНИЕ =

Запустите следующую команду, чтобы получить справку

{{{
    test HELP
}}}

Запустите следующую команду, чтобы встроить функциональность в ваш скрипт 
"filename" 

{{{
    test APPEND-TO filename
}}}

После этого у вам доступны все возможности в скриптах, подобно следующему: 

{{{
    call :if -f "%COMSPEC%" && echo FILE
}}}

Эти функции могут быть доступны во всей системе, где бы вы не исполняли 
ич. Для этого поместите этот скрипт в вашей системе в один из каталогов, 
описанном в переменной окружения `%PATH%` и вызовите как показано в 
примере ниже:

{{{
    call test :if -f "%COMSPEC%" && echo FILE
}}}


== `if EXPR` / `unless EXPR` ==

Вычисляет условное выражение и возвращает (0), если выражение верно, иначе 
(1). Вернет код (2), в случае неправильных аргументов. 


_UNLESS аналогично IF, но смысл проверки противоположен._


Чтобы выполнить расширенные условные операторы, настоящий скрипт 
рассматривает некоторые аргументы (начинающиеся с символа "`-`") как 
специальные операторы. Чтобы избежать возможной путаницы между этими 
операторами и обычными аргументами, рекомендуется оборачивать сравниваемые 
аргументы в двойные кавычки. Операторы же должны оставаться 
незакавыченные. Таким образом, следующие примеры работают правильно: 

{{{
    copy nul equ
    call :if  -e  "equ"      && echo FILE EXISTS
    call :if "-e"  equ  "-e" && echo EQUAL STRINGS
}}}


== Стандартные операторы `IF` ==

{{{
    IF [NOT] ERRORLEVEL number
    IF [NOT] string1==string2
    IF [NOT] EXIST filename

    IF CMDEXTVERSION number
    IF [NOT] DEFINED variable
    IF [/I] string1 compare-op string2
}}}

=== `NOT` ===
Specifies that Windows should carry out the command only if the condition 
is false. 

=== `ERRORLEVEL number` ===
Specifies a true condition if the last program run returned an exit code 
equal to or greater than the number specified. 

=== `string1==string2` ===
Specifies a true condition if the specified text strings match. 

=== `EXIST filename` ===
Specifies a true condition if the specified filename exists.

=== `CMDEXTVERSION number` ===
The CMDEXTVERSION conditional works just like ERRORLEVEL, except it 
iscomparing against an internal version number associated with the Command 
Extensions. 

=== `DEFINED variable` ===
The DEFINED conditional works just like EXIST except it takes an 
environment variable name and returns true if the environment variable is 
defined. 

=== `EQU` ===
Equal

=== `NEQ` ===
Not equal

=== `LSS` ===
Less than

=== `LEQ` ===
Less than or equal

=== `GTR` ===
Greater than

=== `GEQ` ===
Greater than or equal

=== `/I` ===
If specified, says to do case insensitive string compares. The `/I` switch 
can also be used on the `string1==string2` form of `IF`. These comparisons 
are generic, in that if both `string1` and `string2` are both comprised of 
all numeric digits, then the strings are converted to numbers and a 
numeric comparison is performed. 


== Расширенные файловые операторы ==

=== `-a FILE` ===
Верно, если файл существует. 

=== `-b FILE` ===
Верно, если аргумент - дисковое устройство. 

=== `-c FILE` ===
Верно, если аргумент - символьное устройство. 

=== `-d FILE` ===
Верно, если аргумент - каталог. Аналогично `-attr d`.

=== `-e FILE` ===
Верно, если файл существует. 

=== `-f FILE` ===
Верно, если аргумент - обычный файл. 

=== `-h FILE` ===
Верно, если аргумент - ссылка. Аналогично `-attr l`.

=== `-L FILE` ===
Верно, если аргумент - ссылка. Аналогично `-attr l`.

=== `-r FILE` ===
Верно, если файл имеет атрибут только чтение. Аналогично `-attr r`.

=== `-s FILE` ===
Верно, если файл существует и непустой. 

=== `-w FILE` ===
Верно, если файл доступен на запись, например, не установлен атрибут только чтение.
True if the file is writable, i.e. not read only.

=== `-x FILE` ===
Верно, если файл исполнимый. 

=== `-attr ATTR FILE` ===
Верно, если установлен атрибут файла. 

Доступные следующие атрибуты: 
{{{
    Attribute                    Expansion
    FILE_ATTRIBUTE_DIRECTORY     d--------
    FILE_ATTRIBUTE_READONLY      -r-------
    FILE_ATTRIBUTE_ARCHIVE       --a------
    FILE_ATTRIBUTE_HIDDEN        ---h-----
    FILE_ATTRIBUTE_SYSTEM        ----s----
    FILE_ATTRIBUTE_COMPRESSED    -----c---
    FILE_ATTRIBUTE_OFFLINE       ------o--
    FILE_ATTRIBUTE_TEMPORARY     -------t-
    FILE_ATTRIBUTE_REPARSE_POINT --------l
    FILE_ATTRIBUTE_NORMAL        ---------
}}}

=== `-path FILE` ===
Верно, если файл есть в одном из каталогов переменной окружения PATH. 


== Еще файловых операторов ==

=== `FILE1 -nt FILE2` ===
Верно, если FILE1 новее чем FILE2 (в соответствии с временем модификации 
файла). Этот оператор зависит от пользовательских и региональных настроек. 
Это значит, что в общем случае, сравнение не может быть надежным. 

=== `FILE1 -ot FILE2` ===
Верно, если FILE1 старее чем FILE2 (в соответствии с временем модификации 
файла). Этот оператор зависит от пользовательских и региональных настроек. 
Это значит, что в общем случае, сравнение не может быть надежным. 


== Расширенные строковые операторы ==

=== `-n STRING` ===
Верно, если строка непустая.

=== `-z STRING` ===
Верно, если строка пустая.


== Еще строковых операторов ==

=== `STACK -contains NEEDLE` ===
Верно, если STACK содержит NEEDLE.

=== `STACK -starts NEEDLE` ===
Верно, если STACK начинается с NEEDLE.

=== `STACK -ends NEEDLE` ===
Вернл, если STACK завершается NEEDLE.


= ПРИМЕРЫ =

`%COMSPEC%` - файл
{{{
    call :if -f "%COMSPEC%" && echo FILE
}}}

`%COMSPEC%` - не каталог
{{{
    call :unless -d "%COMSPEC%" && echo FILE
}}}

Что-то сделать, если `%STR%` - непустая строка 
{{{
    call :if -n "%STR%" && echo NOTEMPTY
}}}

Что-то сделать, если `%STR%` - пустая строка 
{{{
    call :if -z "%STR%" && echo EMPTY
}}}

Что-то сделать в зависимости от атрибута файла
{{{
    call :if -d "%FILE%" && (
        echo DIR
    ) || ( call :if -f "%FILE%" ) && (
        echo FILE
    ) || (
        echo UNKNOWN
    )
}}}

Пример полного  теста
{{{
    set "f=%~1"
    set "a=%~a1"
    echo FILE: "%f%"
    echo ATTR: "%a%"
    call test :if -a "%f%" && echo -a
    call test :if -b "%f%" && echo -b
    call test :if -c "%f%" && echo -c
    call test :if -d "%f%" && echo -d
    call test :if -e "%f%" && echo -e
    call test :if -f "%f%" && echo -f
    call test :if -h "%f%" && echo -h
    call test :if -L "%f%" && echo -L
    call test :if -r "%f%" && echo -r
    call test :if -s "%f%" && echo -s
    call test :if -w "%f%" && echo -w
    call test :if -x "%f%" && echo -x
}}}


= ОГРАНИЧЕНИЯ =

Хотя стероиды покрывают и унифицируют много неочевидных особенностей 
пакетных файлов, они имеют некоторые ограничения, являющиеся ограничениями 
самих пакетных файлов. 

Мы никогда не можем быть уверены, что аргумерты полностью проверены. В 
любое время пользователь может передать строку, которая будет выполнена 
совсем не так как ожидалось. 

Иногда могут потеряны некоторые символы входных параметров. Например, это 
так для символа `!` в режиме `enabledelayedexpansion`. 


= ССЫЛКИ =

 * [http://www.dostips.com/forum/viewtopic.php?p=6475#p6475 BatchLibrary or how to include batch files]
 * [http://support.microsoft.com/kb/65994 Testing If a Drive or Directory Exists from a Batch File]
 * [http://www.dostips.com/forum/viewtopic.php?f=3&t=2464 How to check if parameter is file (or directory)?]
 * [http://forum.script-coding.com/viewtopic.php?pid=55000#p55000 Elegant idea that inspired this work (Russian forum)]
 * [http://www.dostips.com/DtTipsStringOperations.php#Function.strLen :strLen - returns the length of a string]
 * [http://forum.script-coding.com/viewtopic.php?pid=71000#p71000 The fastest method of the string length estimation (Russian forum)]
 * [http://ss64.com/nt/syntax-args.html#attributes Extended Attributes of a file]


= COPYRIGHTS =

Copyright (c) 2013, 2014 Ildar Shaimordanov

